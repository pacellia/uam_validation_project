
import numpy as np
import pandas as pd
from pathlib import Path
from scipy.optimize import brentq
from scipy.integrate import quad
from cobaya.theory import Theory

class UAMModel(Theory):
    def initialize(self):
        # Hard-coded data paths
        base = Path('/content/uam_validation/data')
        sn_csv  = base / 'pantheon_plus/working_sn_table.csv'
        bao_csv = base / 'bao/working_bao_anisotropic.csv'
        # Load SN redshifts
        sn_df = pd.read_csv(sn_csv)
        zcol  = 'zcmb' if 'zcmb' in sn_df.columns else 'z'
        self.sn_z = sn_df[zcol].to_numpy(dtype=float)
        # Load BAO redshifts
        bao_df = pd.read_csv(bao_csv)
        self.bao_z = bao_df['z'].to_numpy(dtype=float)
        # Constants and caches
        self.c_km_s   = 299792.458
        self.PI2      = np.pi / 2.0
        self.EPS      = 1e-9
        self.EXP_CLIP = 700.0
        self.w_cache  = {}
        self.H_cache  = {}
        self.dL_cache = {}

    def get_requirements(self):
        # SN then BAO redshifts for dL; BAO redshifts for H
        return {
            'luminosity_distance': {'z': np.concatenate([self.sn_z, self.bao_z])},
            'Hubble':              {'z': self.bao_z},
            'rd':                   None,
        }

    def calculate(self, state, want_derived=False, **params_values):
        z_arr = params_values.get('z')
        if z_arr is None:
            return
        H0   = self.provider.get_param('H0')
        beta = self.provider.get_param('beta')
        # Compute and store
        H_vals  = np.array([self._get_H(z, H0, beta) for z in z_arr])
        dL_vals = np.array([self._get_dL(z, H0, beta) for z in z_arr])
        state['Hubble']              = H_vals
        state['luminosity_distance'] = dL_vals

    def _residual(self, w, z, beta):
        cw = np.cos(w)
        c2 = max(cw*cw, self.EPS)
        tw = np.tan(w)
        arg = -beta*tw
        arg = np.clip(arg, -self.EXP_CLIP, self.EXP_CLIP)
        return (1.0+z) - c2*np.exp(arg)

    def _solve_w(self, z, beta):
        if z <= 0:
            return 0.0
        key = (round(z,12), beta)
        if key in self.w_cache:
            return self.w_cache[key]
        a, b = -(self.PI2 - 1e-6), 0.0
        Fa, Fb = self._residual(a,z,beta), self._residual(b,z,beta)
        if Fa*Fb > 0:
            step = 1e-3
            aa = a
            while aa < b and Fa*Fb > 0:
                aa += step
                Fa = self._residual(aa,z,beta)
            a, Fa = aa, Fa
        if Fa*Fb > 0:
            raise ValueError(f'Bracket failed for z={z}, beta={beta}')
        w = brentq(lambda ww: self._residual(ww,z,beta), a, b, xtol=1e-12, rtol=1e-12)
        self.w_cache[key] = w
        return w

    def _get_H(self, z, H0, beta):
        key = (round(z,10), H0, beta)
        if key in self.H_cache:
            return self.H_cache[key]
        w = self._solve_w(z,beta)
        tw = np.tan(w)
        denom = (1.0+z)*(2.0*tw + beta)
        denom = np.sign(denom)*max(abs(denom), self.EPS)
        E = 1.0/denom
        H = H0*E
        self.H_cache[key] = H
        return H

    def _get_dL(self, z, H0, beta):
        key = (round(z,10), H0, beta)
        if key in self.dL_cache:
            return self.dL_cache[key]
        if z <= 0.0:
            return 0.0
        def integrand(zp):
            Hz = self._get_H(zp,H0,beta)
            return self.c_km_s/Hz if Hz>0 else self.c_km_s/self.EPS
        DM, _ = quad(integrand, 0.0, z, epsabs=1e-8, epsrel=1e-6, limit=300)
        dL = (1.0+z)*DM
        self.dL_cache[key] = dL
        return dL
